// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: services/yor/clair/v1/clair.proto

package clair

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on EnableVulnerabilityScanningRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *EnableVulnerabilityScanningRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableVulnerabilityScanningRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// EnableVulnerabilityScanningRequestMultiError, or nil if none found.
func (m *EnableVulnerabilityScanningRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableVulnerabilityScanningRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepositoryId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnableVulnerabilityScanningRequestValidationError{
					field:  "RepositoryId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnableVulnerabilityScanningRequestValidationError{
					field:  "RepositoryId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepositoryId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnableVulnerabilityScanningRequestValidationError{
				field:  "RepositoryId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnableVulnerabilityScanningRequestMultiError(errors)
	}

	return nil
}

// EnableVulnerabilityScanningRequestMultiError is an error wrapping multiple
// validation errors returned by
// EnableVulnerabilityScanningRequest.ValidateAll() if the designated
// constraints aren't met.
type EnableVulnerabilityScanningRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableVulnerabilityScanningRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableVulnerabilityScanningRequestMultiError) AllErrors() []error { return m }

// EnableVulnerabilityScanningRequestValidationError is the validation error
// returned by EnableVulnerabilityScanningRequest.Validate if the designated
// constraints aren't met.
type EnableVulnerabilityScanningRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableVulnerabilityScanningRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableVulnerabilityScanningRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableVulnerabilityScanningRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableVulnerabilityScanningRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableVulnerabilityScanningRequestValidationError) ErrorName() string {
	return "EnableVulnerabilityScanningRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EnableVulnerabilityScanningRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableVulnerabilityScanningRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableVulnerabilityScanningRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableVulnerabilityScanningRequestValidationError{}

// Validate checks the field values on EnableVulnerabilityScanningResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *EnableVulnerabilityScanningResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableVulnerabilityScanningResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// EnableVulnerabilityScanningResponseMultiError, or nil if none found.
func (m *EnableVulnerabilityScanningResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableVulnerabilityScanningResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return EnableVulnerabilityScanningResponseMultiError(errors)
	}

	return nil
}

// EnableVulnerabilityScanningResponseMultiError is an error wrapping multiple
// validation errors returned by
// EnableVulnerabilityScanningResponse.ValidateAll() if the designated
// constraints aren't met.
type EnableVulnerabilityScanningResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableVulnerabilityScanningResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableVulnerabilityScanningResponseMultiError) AllErrors() []error { return m }

// EnableVulnerabilityScanningResponseValidationError is the validation error
// returned by EnableVulnerabilityScanningResponse.Validate if the designated
// constraints aren't met.
type EnableVulnerabilityScanningResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableVulnerabilityScanningResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableVulnerabilityScanningResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableVulnerabilityScanningResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableVulnerabilityScanningResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableVulnerabilityScanningResponseValidationError) ErrorName() string {
	return "EnableVulnerabilityScanningResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EnableVulnerabilityScanningResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableVulnerabilityScanningResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableVulnerabilityScanningResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableVulnerabilityScanningResponseValidationError{}

// Validate checks the field values on ClairReportPackage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClairReportPackage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairReportPackage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairReportPackageMultiError, or nil if none found.
func (m *ClairReportPackage) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairReportPackage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Kind

	// no validation rules for Arch

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClairReportPackageValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClairReportPackageValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClairReportPackageValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClairReportPackageMultiError(errors)
	}

	return nil
}

// ClairReportPackageMultiError is an error wrapping multiple validation errors
// returned by ClairReportPackage.ValidateAll() if the designated constraints
// aren't met.
type ClairReportPackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairReportPackageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairReportPackageMultiError) AllErrors() []error { return m }

// ClairReportPackageValidationError is the validation error returned by
// ClairReportPackage.Validate if the designated constraints aren't met.
type ClairReportPackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairReportPackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairReportPackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairReportPackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairReportPackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairReportPackageValidationError) ErrorName() string {
	return "ClairReportPackageValidationError"
}

// Error satisfies the builtin error interface
func (e ClairReportPackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairReportPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairReportPackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairReportPackageValidationError{}

// Validate checks the field values on SubmitManifestToScanResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitManifestToScanResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitManifestToScanResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitManifestToScanResponseMultiError, or nil if none found.
func (m *SubmitManifestToScanResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitManifestToScanResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for ManifestHash

	// no validation rules for State

	// no validation rules for Err

	{
		sorted_keys := make([]string, len(m.GetPackages()))
		i := 0
		for key := range m.GetPackages() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPackages()[key]
			_ = val

			// no validation rules for Packages[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Packages[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Packages[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SubmitManifestToScanResponseValidationError{
						field:  fmt.Sprintf("Packages[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetDistributions()))
		i := 0
		for key := range m.GetDistributions() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDistributions()[key]
			_ = val

			// no validation rules for Distributions[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Distributions[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Distributions[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SubmitManifestToScanResponseValidationError{
						field:  fmt.Sprintf("Distributions[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetRepository()))
		i := 0
		for key := range m.GetRepository() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRepository()[key]
			_ = val

			// no validation rules for Repository[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Repository[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Repository[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SubmitManifestToScanResponseValidationError{
						field:  fmt.Sprintf("Repository[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnvironments()))
		i := 0
		for key := range m.GetEnvironments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnvironments()[key]
			_ = val

			// no validation rules for Environments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Environments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SubmitManifestToScanResponseValidationError{
							field:  fmt.Sprintf("Environments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SubmitManifestToScanResponseValidationError{
						field:  fmt.Sprintf("Environments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return SubmitManifestToScanResponseMultiError(errors)
	}

	return nil
}

// SubmitManifestToScanResponseMultiError is an error wrapping multiple
// validation errors returned by SubmitManifestToScanResponse.ValidateAll() if
// the designated constraints aren't met.
type SubmitManifestToScanResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitManifestToScanResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitManifestToScanResponseMultiError) AllErrors() []error { return m }

// SubmitManifestToScanResponseValidationError is the validation error returned
// by SubmitManifestToScanResponse.Validate if the designated constraints
// aren't met.
type SubmitManifestToScanResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitManifestToScanResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitManifestToScanResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitManifestToScanResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitManifestToScanResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitManifestToScanResponseValidationError) ErrorName() string {
	return "SubmitManifestToScanResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitManifestToScanResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitManifestToScanResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitManifestToScanResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitManifestToScanResponseValidationError{}

// Validate checks the field values on ClairDescriptor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClairDescriptor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairDescriptor with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairDescriptorMultiError, or nil if none found.
func (m *ClairDescriptor) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairDescriptor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	// no validation rules for Uri

	{
		sorted_keys := make([]string, len(m.GetHeaders()))
		i := 0
		for key := range m.GetHeaders() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetHeaders()[key]
			_ = val

			// no validation rules for Headers[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClairDescriptorValidationError{
							field:  fmt.Sprintf("Headers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClairDescriptorValidationError{
							field:  fmt.Sprintf("Headers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClairDescriptorValidationError{
						field:  fmt.Sprintf("Headers[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ClairDescriptorMultiError(errors)
	}

	return nil
}

// ClairDescriptorMultiError is an error wrapping multiple validation errors
// returned by ClairDescriptor.ValidateAll() if the designated constraints
// aren't met.
type ClairDescriptorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairDescriptorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairDescriptorMultiError) AllErrors() []error { return m }

// ClairDescriptorValidationError is the validation error returned by
// ClairDescriptor.Validate if the designated constraints aren't met.
type ClairDescriptorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairDescriptorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairDescriptorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairDescriptorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairDescriptorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairDescriptorValidationError) ErrorName() string { return "ClairDescriptorValidationError" }

// Error satisfies the builtin error interface
func (e ClairDescriptorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairDescriptor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairDescriptorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairDescriptorValidationError{}

// Validate checks the field values on SubmitManifestToScanRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmitManifestToScanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmitManifestToScanRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmitManifestToScanRequestMultiError, or nil if none found.
func (m *SubmitManifestToScanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmitManifestToScanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	if len(errors) > 0 {
		return SubmitManifestToScanRequestMultiError(errors)
	}

	return nil
}

// SubmitManifestToScanRequestMultiError is an error wrapping multiple
// validation errors returned by SubmitManifestToScanRequest.ValidateAll() if
// the designated constraints aren't met.
type SubmitManifestToScanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmitManifestToScanRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmitManifestToScanRequestMultiError) AllErrors() []error { return m }

// SubmitManifestToScanRequestValidationError is the validation error returned
// by SubmitManifestToScanRequest.Validate if the designated constraints
// aren't met.
type SubmitManifestToScanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmitManifestToScanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmitManifestToScanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmitManifestToScanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmitManifestToScanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmitManifestToScanRequestValidationError) ErrorName() string {
	return "SubmitManifestToScanRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubmitManifestToScanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmitManifestToScanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmitManifestToScanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmitManifestToScanRequestValidationError{}

// Validate checks the field values on GetVulnerabilityReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVulnerabilityReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVulnerabilityReportRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetVulnerabilityReportRequestMultiError, or nil if none found.
func (m *GetVulnerabilityReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVulnerabilityReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ManifestId

	if len(errors) > 0 {
		return GetVulnerabilityReportRequestMultiError(errors)
	}

	return nil
}

// GetVulnerabilityReportRequestMultiError is an error wrapping multiple
// validation errors returned by GetVulnerabilityReportRequest.ValidateAll()
// if the designated constraints aren't met.
type GetVulnerabilityReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVulnerabilityReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVulnerabilityReportRequestMultiError) AllErrors() []error { return m }

// GetVulnerabilityReportRequestValidationError is the validation error
// returned by GetVulnerabilityReportRequest.Validate if the designated
// constraints aren't met.
type GetVulnerabilityReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVulnerabilityReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVulnerabilityReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVulnerabilityReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVulnerabilityReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVulnerabilityReportRequestValidationError) ErrorName() string {
	return "GetVulnerabilityReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetVulnerabilityReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVulnerabilityReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVulnerabilityReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVulnerabilityReportRequestValidationError{}

// Validate checks the field values on ClairIndexManifestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClairIndexManifestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairIndexManifestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairIndexManifestRequestMultiError, or nil if none found.
func (m *ClairIndexManifestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairIndexManifestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	for idx, item := range m.GetLayers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClairIndexManifestRequestValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClairIndexManifestRequestValidationError{
						field:  fmt.Sprintf("Layers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClairIndexManifestRequestValidationError{
					field:  fmt.Sprintf("Layers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClairIndexManifestRequestMultiError(errors)
	}

	return nil
}

// ClairIndexManifestRequestMultiError is an error wrapping multiple validation
// errors returned by ClairIndexManifestRequest.ValidateAll() if the
// designated constraints aren't met.
type ClairIndexManifestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairIndexManifestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairIndexManifestRequestMultiError) AllErrors() []error { return m }

// ClairIndexManifestRequestValidationError is the validation error returned by
// ClairIndexManifestRequest.Validate if the designated constraints aren't met.
type ClairIndexManifestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairIndexManifestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairIndexManifestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairIndexManifestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairIndexManifestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairIndexManifestRequestValidationError) ErrorName() string {
	return "ClairIndexManifestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClairIndexManifestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairIndexManifestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairIndexManifestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairIndexManifestRequestValidationError{}

// Validate checks the field values on ClairPackageSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClairPackageSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairPackageSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairPackageSourceMultiError, or nil if none found.
func (m *ClairPackageSource) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairPackageSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Kind

	if len(errors) > 0 {
		return ClairPackageSourceMultiError(errors)
	}

	return nil
}

// ClairPackageSourceMultiError is an error wrapping multiple validation errors
// returned by ClairPackageSource.ValidateAll() if the designated constraints
// aren't met.
type ClairPackageSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairPackageSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairPackageSourceMultiError) AllErrors() []error { return m }

// ClairPackageSourceValidationError is the validation error returned by
// ClairPackageSource.Validate if the designated constraints aren't met.
type ClairPackageSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairPackageSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairPackageSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairPackageSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairPackageSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairPackageSourceValidationError) ErrorName() string {
	return "ClairPackageSourceValidationError"
}

// Error satisfies the builtin error interface
func (e ClairPackageSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairPackageSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairPackageSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairPackageSourceValidationError{}

// Validate checks the field values on ClairPackage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClairPackage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairPackage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClairPackageMultiError, or
// nil if none found.
func (m *ClairPackage) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairPackage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClairPackageValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClairPackageValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClairPackageValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Arch

	if len(errors) > 0 {
		return ClairPackageMultiError(errors)
	}

	return nil
}

// ClairPackageMultiError is an error wrapping multiple validation errors
// returned by ClairPackage.ValidateAll() if the designated constraints aren't met.
type ClairPackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairPackageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairPackageMultiError) AllErrors() []error { return m }

// ClairPackageValidationError is the validation error returned by
// ClairPackage.Validate if the designated constraints aren't met.
type ClairPackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairPackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairPackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairPackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairPackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairPackageValidationError) ErrorName() string { return "ClairPackageValidationError" }

// Error satisfies the builtin error interface
func (e ClairPackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairPackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairPackageValidationError{}

// Validate checks the field values on ClairDistribution with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClairDistribution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairDistribution with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairDistributionMultiError, or nil if none found.
func (m *ClairDistribution) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairDistribution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Did

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for VersionCodeName

	// no validation rules for VersionId

	// no validation rules for Arch

	// no validation rules for Cpe

	// no validation rules for PrettyName

	if len(errors) > 0 {
		return ClairDistributionMultiError(errors)
	}

	return nil
}

// ClairDistributionMultiError is an error wrapping multiple validation errors
// returned by ClairDistribution.ValidateAll() if the designated constraints
// aren't met.
type ClairDistributionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairDistributionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairDistributionMultiError) AllErrors() []error { return m }

// ClairDistributionValidationError is the validation error returned by
// ClairDistribution.Validate if the designated constraints aren't met.
type ClairDistributionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairDistributionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairDistributionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairDistributionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairDistributionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairDistributionValidationError) ErrorName() string {
	return "ClairDistributionValidationError"
}

// Error satisfies the builtin error interface
func (e ClairDistributionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairDistribution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairDistributionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairDistributionValidationError{}

// Validate checks the field values on ClairEnvironmentItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClairEnvironmentItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairEnvironmentItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairEnvironmentItemMultiError, or nil if none found.
func (m *ClairEnvironmentItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairEnvironmentItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PackageDb

	// no validation rules for IntroducedIn

	// no validation rules for DistributionId

	if len(errors) > 0 {
		return ClairEnvironmentItemMultiError(errors)
	}

	return nil
}

// ClairEnvironmentItemMultiError is an error wrapping multiple validation
// errors returned by ClairEnvironmentItem.ValidateAll() if the designated
// constraints aren't met.
type ClairEnvironmentItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairEnvironmentItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairEnvironmentItemMultiError) AllErrors() []error { return m }

// ClairEnvironmentItemValidationError is the validation error returned by
// ClairEnvironmentItem.Validate if the designated constraints aren't met.
type ClairEnvironmentItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairEnvironmentItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairEnvironmentItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairEnvironmentItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairEnvironmentItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairEnvironmentItemValidationError) ErrorName() string {
	return "ClairEnvironmentItemValidationError"
}

// Error satisfies the builtin error interface
func (e ClairEnvironmentItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairEnvironmentItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairEnvironmentItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairEnvironmentItemValidationError{}

// Validate checks the field values on ClairRepository with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClairRepository) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairRepository with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairRepositoryMultiError, or nil if none found.
func (m *ClairRepository) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairRepository) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ClairRepositoryMultiError(errors)
	}

	return nil
}

// ClairRepositoryMultiError is an error wrapping multiple validation errors
// returned by ClairRepository.ValidateAll() if the designated constraints
// aren't met.
type ClairRepositoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairRepositoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairRepositoryMultiError) AllErrors() []error { return m }

// ClairRepositoryValidationError is the validation error returned by
// ClairRepository.Validate if the designated constraints aren't met.
type ClairRepositoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairRepositoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairRepositoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairRepositoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairRepositoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairRepositoryValidationError) ErrorName() string { return "ClairRepositoryValidationError" }

// Error satisfies the builtin error interface
func (e ClairRepositoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairRepository.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairRepositoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairRepositoryValidationError{}

// Validate checks the field values on ClairVulnerability with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClairVulnerability) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairVulnerability with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairVulnerabilityMultiError, or nil if none found.
func (m *ClairVulnerability) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairVulnerability) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Updater

	// no validation rules for Name

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetIssued()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Issued",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Issued",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssued()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClairVulnerabilityValidationError{
				field:  "Issued",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Links

	// no validation rules for Severity

	// no validation rules for NormalizedSeverity

	if all {
		switch v := interface{}(m.GetPackage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Package",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Package",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPackage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClairVulnerabilityValidationError{
				field:  "Package",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDistribution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Distribution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Distribution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDistribution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClairVulnerabilityValidationError{
				field:  "Distribution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRepository()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Repository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClairVulnerabilityValidationError{
					field:  "Repository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepository()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClairVulnerabilityValidationError{
				field:  "Repository",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FixedInVersion

	if len(errors) > 0 {
		return ClairVulnerabilityMultiError(errors)
	}

	return nil
}

// ClairVulnerabilityMultiError is an error wrapping multiple validation errors
// returned by ClairVulnerability.ValidateAll() if the designated constraints
// aren't met.
type ClairVulnerabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairVulnerabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairVulnerabilityMultiError) AllErrors() []error { return m }

// ClairVulnerabilityValidationError is the validation error returned by
// ClairVulnerability.Validate if the designated constraints aren't met.
type ClairVulnerabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairVulnerabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairVulnerabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairVulnerabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairVulnerabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairVulnerabilityValidationError) ErrorName() string {
	return "ClairVulnerabilityValidationError"
}

// Error satisfies the builtin error interface
func (e ClairVulnerabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairVulnerability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairVulnerabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairVulnerabilityValidationError{}

// Validate checks the field values on ClairEnrichment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClairEnrichment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairEnrichment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairEnrichmentMultiError, or nil if none found.
func (m *ClairEnrichment) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairEnrichment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ClairEnrichmentMultiError(errors)
	}

	return nil
}

// ClairEnrichmentMultiError is an error wrapping multiple validation errors
// returned by ClairEnrichment.ValidateAll() if the designated constraints
// aren't met.
type ClairEnrichmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairEnrichmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairEnrichmentMultiError) AllErrors() []error { return m }

// ClairEnrichmentValidationError is the validation error returned by
// ClairEnrichment.Validate if the designated constraints aren't met.
type ClairEnrichmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairEnrichmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairEnrichmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairEnrichmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairEnrichmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairEnrichmentValidationError) ErrorName() string { return "ClairEnrichmentValidationError" }

// Error satisfies the builtin error interface
func (e ClairEnrichmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairEnrichment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairEnrichmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairEnrichmentValidationError{}

// Validate checks the field values on ClairVulnerabilityIdList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClairVulnerabilityIdList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClairVulnerabilityIdList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClairVulnerabilityIdListMultiError, or nil if none found.
func (m *ClairVulnerabilityIdList) ValidateAll() error {
	return m.validate(true)
}

func (m *ClairVulnerabilityIdList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ClairVulnerabilityIdListMultiError(errors)
	}

	return nil
}

// ClairVulnerabilityIdListMultiError is an error wrapping multiple validation
// errors returned by ClairVulnerabilityIdList.ValidateAll() if the designated
// constraints aren't met.
type ClairVulnerabilityIdListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClairVulnerabilityIdListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClairVulnerabilityIdListMultiError) AllErrors() []error { return m }

// ClairVulnerabilityIdListValidationError is the validation error returned by
// ClairVulnerabilityIdList.Validate if the designated constraints aren't met.
type ClairVulnerabilityIdListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClairVulnerabilityIdListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClairVulnerabilityIdListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClairVulnerabilityIdListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClairVulnerabilityIdListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClairVulnerabilityIdListValidationError) ErrorName() string {
	return "ClairVulnerabilityIdListValidationError"
}

// Error satisfies the builtin error interface
func (e ClairVulnerabilityIdListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClairVulnerabilityIdList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClairVulnerabilityIdListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClairVulnerabilityIdListValidationError{}

// Validate checks the field values on GetVulnerabilityReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetVulnerabilityReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVulnerabilityReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetVulnerabilityReportResponseMultiError, or nil if none found.
func (m *GetVulnerabilityReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVulnerabilityReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ManifestHash

	// no validation rules for State

	// no validation rules for Err

	// no validation rules for Success

	{
		sorted_keys := make([]string, len(m.GetPackages()))
		i := 0
		for key := range m.GetPackages() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPackages()[key]
			_ = val

			// no validation rules for Packages[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Packages[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Packages[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetVulnerabilityReportResponseValidationError{
						field:  fmt.Sprintf("Packages[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetDistributions()))
		i := 0
		for key := range m.GetDistributions() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDistributions()[key]
			_ = val

			// no validation rules for Distributions[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Distributions[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Distributions[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetVulnerabilityReportResponseValidationError{
						field:  fmt.Sprintf("Distributions[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetEnvironments()))
		i := 0
		for key := range m.GetEnvironments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetEnvironments()[key]
			_ = val

			// no validation rules for Environments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Environments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Environments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetVulnerabilityReportResponseValidationError{
						field:  fmt.Sprintf("Environments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetPackageVulnerabilities()))
		i := 0
		for key := range m.GetPackageVulnerabilities() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPackageVulnerabilities()[key]
			_ = val

			// no validation rules for PackageVulnerabilities[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("PackageVulnerabilities[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("PackageVulnerabilities[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetVulnerabilityReportResponseValidationError{
						field:  fmt.Sprintf("PackageVulnerabilities[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetEnrichments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetVulnerabilityReportResponseValidationError{
					field:  "Enrichments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetVulnerabilityReportResponseValidationError{
					field:  "Enrichments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnrichments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetVulnerabilityReportResponseValidationError{
				field:  "Enrichments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetRepository()))
		i := 0
		for key := range m.GetRepository() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRepository()[key]
			_ = val

			// no validation rules for Repository[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Repository[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Repository[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetVulnerabilityReportResponseValidationError{
						field:  fmt.Sprintf("Repository[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetVulnerabilities()))
		i := 0
		for key := range m.GetVulnerabilities() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetVulnerabilities()[key]
			_ = val

			// no validation rules for Vulnerabilities[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Vulnerabilities[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetVulnerabilityReportResponseValidationError{
							field:  fmt.Sprintf("Vulnerabilities[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetVulnerabilityReportResponseValidationError{
						field:  fmt.Sprintf("Vulnerabilities[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetVulnerabilityReportResponseMultiError(errors)
	}

	return nil
}

// GetVulnerabilityReportResponseMultiError is an error wrapping multiple
// validation errors returned by GetVulnerabilityReportResponse.ValidateAll()
// if the designated constraints aren't met.
type GetVulnerabilityReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVulnerabilityReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVulnerabilityReportResponseMultiError) AllErrors() []error { return m }

// GetVulnerabilityReportResponseValidationError is the validation error
// returned by GetVulnerabilityReportResponse.Validate if the designated
// constraints aren't met.
type GetVulnerabilityReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVulnerabilityReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVulnerabilityReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVulnerabilityReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVulnerabilityReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVulnerabilityReportResponseValidationError) ErrorName() string {
	return "GetVulnerabilityReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetVulnerabilityReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVulnerabilityReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVulnerabilityReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVulnerabilityReportResponseValidationError{}
